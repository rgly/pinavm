#include <systemc>

#include <string>

// For JIT
#include "llvm/LLVMContext.h"
#include "llvm/Module.h"
#include "llvm/Type.h"
#include "llvm/Bitcode/ReaderWriter.h"
#include "llvm/CodeGen/LinkAllCodegenComponents.h"
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/ExecutionEngine/Interpreter.h"
#include "llvm/ExecutionEngine/JIT.h"
#include "llvm/ExecutionEngine/JITEventListener.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/ManagedStatic.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/PluginLoader.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/System/Process.h"
#include "llvm/System/Signals.h"
#include "llvm/Target/TargetSelect.h"
#include <cerrno>
using namespace llvm;

#include "llvm/System/DynamicLibrary.h"


//#include "BCLoader.h"

#include "FrontendItf.hpp"
#include "SimpleBackend.h"
#include "PromelaBackend.h"
#include "42Backend.h"
#include "TwetoBackend.h"

// get a -load option.
//#include "llvm/Support/PluginLoader.h"

static cl::opt < bool >
Bug("bug", cl::desc("Insert bug int the last process (in the file generated by the backend"));

static cl::opt < bool >
RelativeClocks("relative-clocks", cl::desc("Use relative clocks in the backend"));

static cl::opt < bool >
EventsAsBool("events-as-bool", cl::desc("Encode events using booleans instead of integers"));


/*** Global options ***/
static cl::opt < std::string >
InputFilename(cl::Positional, cl::desc("<input bitcode file>"),
	      cl::init("-"), cl::value_desc("filename"));

static cl::opt < std::string >
Args("args", cl::desc("<input args>"),
	      cl::init(""), cl::value_desc("string"));

/*
TODO: this would be better than Args, to allow having multiple arguments.
static cl::list<std::string>
InputArgv(cl::ConsumeAfter, cl::desc("<program arguments>..."));
*/


static cl::opt < std::string >
OutputFilename("o", cl::desc("Override output filename"),
	       cl::value_desc("filename"), cl::init("-"));

static cl::opt < std::string >
Backend("b", cl::desc("Backend to use"),
	cl::value_desc("backend-name"), cl::init("-"));

static cl::opt < bool >
PrintElab("print-elab", cl::desc("Print architecture after elaboration"));

static cl::opt < bool >
PrintIR("print-ir",
	cl::desc("Print Intermediate representation for all processes"));

static cl::opt < bool >
DisableDbgMsg("dis-dbg-msg", cl::desc("Disable debug messages"));

static cl::opt < bool >
InlineFcts("inline", cl::desc("Inline all functions"));

bool disable_debug_msg;

extern "C"
void pinavm_callback();
extern "C" bool pinavm_simulation_callback();
Module *Mod;
void pinavm_callback()
{
	TRACE_1("Entering PinaVM (callback), building module\n");

	if (DisableDbgMsg) {
		disable_debug_msg = true;
	} else {
		disable_debug_msg = false;
	}

	Frontend *fe = launch_frontend(InputFilename, InlineFcts,Mod);

	if (PrintIR) {
		fe->printIR();
	}
	if (PrintElab) {
		fe->printElab("");
	}

	if (Backend != "-") {
		if (Backend == "simple" || Backend == "Simple") {
			launch_simplebackend(fe, OutputFilename, EventsAsBool, RelativeClocks);
		} else if (Backend == "promela" || Backend == "Promela") {
			launch_promelabackend(fe, OutputFilename, EventsAsBool, RelativeClocks, Bug);
		} else if (Backend == "42") {
		        launch_42backend(fe, OutputFilename, EventsAsBool, RelativeClocks, Bug);
		} 
		// Tweto backend
		else if(Backend == "tweto" || Backend == "Tweto") {
			launch_twetobackend(fe);
		} else {
			ERROR("Backend " << Backend << " unknown\n");
		}
	}
}

bool pinavm_simulation_callback() {
	if(Backend == "tweto" || Backend == "Tweto") {
		TRACE_1("Launching simulation...\n");
		return true; // Run the simulation
	} else {
		return false; // Do not run the simulation
	}
	
}

static ExecutionEngine *EE = 0;

int load_and_run_sc_main(std::string & InputFile)
{
	std::vector<std::string> InputArgv;
	std::string ErrorMsg;

	// Lot of copy-paste from lli.cpp
	LLVMContext &Context = getGlobalContext();

	// If we have a native target, initialize it to ensure it is linked in and
	// usable by the JIT.
	InitializeNativeTarget();

	// So that JIT-ed code can call pinavm_callback.
	//sys::DynamicLibrary::AddSymbol("pinavm_callback", (void *)pinavm_callback);

	// Load the bitcode...
	//Module *Mod = NULL;
	if (MemoryBuffer *Buffer = MemoryBuffer::getFileOrSTDIN(InputFile,&ErrorMsg)){
		Mod = ParseBitcodeFile(Buffer, Context, &ErrorMsg);
		//Mod = getLazyBitcodeModule(Buffer, Context, &ErrorMsg);
		if (!Mod) delete Buffer;
	}

	if (!Mod) {
		errs() << "error loading program '" << InputFile << "': "
		       << ErrorMsg << "\n";
		exit(1);
	} else {
		TRACE_2("bitcode file loaded\n");
	}

	EngineBuilder builder(Mod);
	builder.setErrorStr(&ErrorMsg);
	builder.setEngineKind(EngineKind::JIT);

	builder.setOptLevel(CodeGenOpt::None);
	EE = builder.create();
	if (!EE) {
		if (!ErrorMsg.empty())
			errs() << "error creating EE: " << ErrorMsg << "\n";
		else
			errs() << "unknown error creating EE!\n";
		exit(1);
	}

	//EE->RegisterJITEventListener(createOProfileJITEventListener());

	// TODO: manage multiple arguments correctly.

	// Add the module's name to the start of the vector of arguments to main().
	InputArgv.push_back("main.exe");
	InputArgv.push_back(Args);

	// Call the main function from M as if its signature were:
	//   int main (int argc, char **argv, const char **envp)
	// using the contents of Args to determine argc & argv, and the contents of
	// EnvVars to determine envp.
	//
	std::string EntryFunc = "sc_main";
	Function *EntryFn = Mod->getFunction(EntryFunc);
	if (!EntryFn) {
		errs() << '\'' << EntryFunc << "\' function not found in module.\n";
		return -1;
	}

	// TODO: is this usefull?
	// If the program doesn't explicitly call exit, we will need the Exit
	// function later on to make an explicit call, so get the function now.
	Constant *Exit = Mod->getOrInsertFunction("exit", Type::getVoidTy(Context),
						  Type::getInt32Ty(Context),
						  NULL);

	// Reset errno to zero on entry to main.
	errno = 0;


	// Run static constructors.
	EE->runStaticConstructorsDestructors(false);


	TRACE_2("Running elaboration\n");
	// Run main.
	int Result = EE->runFunctionAsMain(EntryFn, InputArgv, NULL);

	// Run static destructors.
	EE->runStaticConstructorsDestructors(true);	

	// If the program didn't call exit explicitly, we should call it now.
	// This ensures that any atexit handlers get called correctly.
	if (Function *ExitF = dyn_cast<Function>(Exit)) {
		std::vector<GenericValue> Args;
		GenericValue ResultGV;
		ResultGV.IntVal = APInt(32, Result);
		Args.push_back(ResultGV);
		EE->runFunction(ExitF, Args);
		errs() << "ERROR: exit(" << Result << ") returned!\n";
		abort();
	} else {
		errs() << "ERROR: exit defined with wrong prototype!\n";
		abort();
	}
}

int toplevel_main(int argc, char **argv)
{
//	llvm_shutdown_obj X;	// Call llvm_shutdown() on exit.

	try {

		// If we have a native target, initialize it to ensure it is linked in and
		// usable by the JIT.
		InitializeNativeTarget();

		cl::ParseCommandLineOptions(argc, argv, "llvm .bc -> .bc modular optimizer and analysis printer\n");

		sys::PrintStackTraceOnErrorSignal();

		TRACE_1("Loading and running bitcode file\n");
		// load_bc_and_run_sc_main(argc, argv, environ);
		load_and_run_sc_main(InputFilename);
	} catch(const std::string & msg) {
		errs() << argv[0] << ": " << msg << "\n";
	} catch(...) {
		errs() << argv[0] <<
		    ": Unexpected unknown exception occurred.\n";
	}
	TRACE_1("Shutdown...\n");
//	llvm_shutdown();
	return 0;
}
