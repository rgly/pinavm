//#include <systemc>

#include <string>
#include <algorithm>
#include <cstdio>

// For JIT
#include "llvm/LLVMContext.h"
#include "llvm/Module.h"
#include "llvm/Type.h"
//#include "llvm/Bitcode/ReaderWriter.h"
#include "llvm/CodeGen/LinkAllCodegenComponents.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/ExecutionEngine/Interpreter.h"
#include "llvm/ExecutionEngine/JIT.h"
#include "llvm/ExecutionEngine/JITEventListener.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/ManagedStatic.h"
#include "llvm/Support/PluginLoader.h"
#include "llvm/Support/PrettyStackTrace.h"
#include "llvm/Support/raw_ostream.h"
//#include "llvm/Support/Process.h"
#include "llvm/Support/IRReader.h"
#include "llvm/Support/Signals.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/Support/DynamicLibrary.h"
#include <cerrno>
using namespace llvm;


//#include "BCLoader.h"

#include "FrontendItf.hpp"
// a container for options. check util/ for more details.
#include "BackendOption.h"
extern bool launch_backends(Frontend*, std::string backend, BackendOption&);

#include <ctime>
#include <sys/time.h>

// get a -load option.
//#include "llvm/Support/PluginLoader.h"

static cl::opt < bool >
Bug("bug", cl::desc("Insert bug int the last process (in the file generated by the backend"));

static cl::opt < bool >
RelativeClocks("relative-clocks", cl::desc("Use relative clocks in the backend"));

static cl::opt < bool >
EventsAsBool("events-as-bool", cl::desc("Encode events using booleans instead of integers"));


/*** Global options ***/
static cl::opt < std::string >
InputFilename(cl::Positional, cl::desc("<input bitcode file>"),
	      cl::init("-"), cl::value_desc("filename"));

static cl::list<std::string>
InputArgv(cl::ConsumeAfter, cl::desc("<program arguments>..."));


static cl::opt < std::string >
OutputFilename("o", cl::desc("Override output filename"),
	       cl::value_desc("filename"), cl::init("-"));

static cl::opt < std::string >
Backend("b", cl::desc("Backend to use"),
	cl::value_desc("backend-name"), cl::init("-"));

static cl::opt < bool >
PrintElab("print-elab", cl::desc("Print architecture after elaboration"));

static cl::opt < bool >
PrintIR("print-ir",
	cl::desc("Print Intermediate representation for all processes"));

static cl::opt < bool >
PrintDuration("print-dura",
        cl::desc("Print the processing duration of the Tweto backend"));

static cl::opt < bool >
DisableDbgMsg("dis-dbg-msg", cl::desc("Disable debug messages"));

static cl::opt < bool >
DisableOptDbgMsg("dis-opt-msg", cl::desc("Disable debug messages from the optimizer"));

static cl::opt < bool >
InlineFcts("inline", cl::desc("Inline all functions"));

bool disable_debug_msg;
static ExecutionEngine *EE = 0;

extern "C" void 
pinavm_callback(sc_core::sc_simcontext* context, const sc_core::sc_time& duration);
Module *Mod;
void pinavm_callback(sc_core::sc_simcontext* context, 
                     const sc_core::sc_time& duration)
{
	TRACE_1("Entering PinaVM (callback), building module\n");

	Frontend *fe = launch_frontend(InputFilename, InlineFcts,Mod);

	if (PrintIR) {
		fe->printIR();
	}
	if (PrintElab) {
		fe->printElab("");
	}
    
    struct timeval start;
    struct timeval end;     
    long mtime, seconds, useconds;
    gettimeofday(&start, NULL);

    BackendOption option;
    option.OutputFilename = OutputFilename;
    option.EventsAsBool = EventsAsBool;
    option.RelativeClocks = RelativeClocks;
    option.Bug = Bug;
    option.EE = EE;
    option.context = context;
    option.duration = &duration;
    option.DisableMsg = DisableDbgMsg;
    option.DisableOptDbgMsg = DisableOptDbgMsg;
    
    // Running backends.
    bool match_backend = launch_backends(fe, Backend, option);
    if (! match_backend) {
        ERROR("Backend " << Backend << " unknown\n"); 
    }
    
    if(PrintDuration) {
        gettimeofday(&end, NULL);
        seconds  = end.tv_sec  - start.tv_sec;
        useconds = end.tv_usec - start.tv_usec;
        mtime = ((seconds) * 1000 + useconds/1000.0) + 0.5;
        printf("%ld\n", mtime);
    }
}

void resolve_weak_symbol(GlobalVariable &GV) {
	if (GV.isWeakForLinker()) {
		void *Ptr = EE->getPointerToGlobalIfAvailable(&GV);
		// already linked, nothing to do.
		if (Ptr) return;
		Ptr = sys::DynamicLibrary::SearchForAddressOfSymbol(GV.getName());
		// Symbol isn't define in a library, let the JIT
		// engine create the symbol later
		if (!Ptr) return;
		// Interesting case: the symbol has weak linkage, is
		// defined in a library. LLVM badly manages this in
		// JIT::getOrEmitGlobalVariable => do it properly
		// ourselves now.
		EE->addGlobalMapping(&GV, Ptr);
	}
}

int load_and_run_sc_main(std::string & InputFile)
{
	std::string ErrorMsg;

	// Lot of copy-paste from lli.cpp
	LLVMContext &Context = getGlobalContext();

	// If we have a native target, initialize it to ensure it is linked in and
	// usable by the JIT.
	InitializeNativeTarget();

	// So that JIT-ed code can call pinavm_callback.
	//sys::DynamicLibrary::AddSymbol("pinavm_callback", (void *)pinavm_callback);

	// Load the bitcode file as LLVM module
	SMDiagnostic smdiagnostic;
	Mod = ParseIRFile(InputFile, smdiagnostic, Context);

	if (!Mod) {
		errs() << "error loading program '" << InputFile << "': "
		       << smdiagnostic.getMessage() << "\n";
		exit(1);
	} else {
		TRACE_2("bitcode file loaded\n");
	}

	EngineBuilder builder(Mod);
	builder.setErrorStr(&ErrorMsg);
	builder.setEngineKind(EngineKind::JIT);

	builder.setOptLevel(CodeGenOpt::None);
	EE = builder.create();
	if (!EE) {
		if (!ErrorMsg.empty())
			errs() << "error creating EE: " << ErrorMsg << "\n";
		else
			errs() << "unknown error creating EE!\n";
		exit(1);
	}

	TRACE_5("Resolving weak and linkonce symbols in ExecutionEngine");
	std::for_each (Mod->global_begin(), Mod->global_end(),
		       resolve_weak_symbol);
	TRACE_5("Resolving weak and linkonce symbols: done");

	//EE->RegisterJITEventListener(createOProfileJITEventListener());

	// Add the module's name to the start of the vector of arguments to main().
	InputArgv.insert(InputArgv.begin(), "main.exe");

	// Call the main function from M as if its signature were:
	//   int main (int argc, char **argv, const char **envp)
	// using the contents of Args to determine argc & argv, and the contents of
	// EnvVars to determine envp.
	//
	std::string EntryFunc = "sc_main";
	Function *EntryFn = Mod->getFunction(EntryFunc);
	if (!EntryFn) {
		errs() << '\'' << EntryFunc << "\' function not found in module.\n";
		return -1;
	}

	// TODO: is this usefull?
	// If the program doesn't explicitly call exit, we will need the Exit
	// function later on to make an explicit call, so get the function now.
	Constant *Exit = Mod->getOrInsertFunction("exit", Type::getVoidTy(Context),
						  Type::getInt32Ty(Context),
						  NULL);

	// Reset errno to zero on entry to main.
	errno = 0;


	// Run static constructors.
	EE->runStaticConstructorsDestructors(false);
    
	TRACE_2("Running elaboration\n");
	// Run main.
	int Result = EE->runFunctionAsMain(EntryFn, InputArgv, NULL);

	// Run static destructors.
	EE->runStaticConstructorsDestructors(true);	

	// If the program didn't call exit explicitly, we should call it now.
	// This ensures that any atexit handlers get called correctly.
	if (Function *ExitF = dyn_cast<Function>(Exit)) {
		std::vector<GenericValue> Args;
		GenericValue ResultGV;
		ResultGV.IntVal = APInt(32, Result);
		Args.push_back(ResultGV);
		EE->runFunction(ExitF, Args);
		errs() << "ERROR: exit(" << Result << ") returned!\n";
		abort();
	} else {
		errs() << "ERROR: exit defined with wrong prototype!\n";
		abort();
	}
}

int toplevel_main(int argc, char **argv)
{
//	llvm_shutdown_obj X;	// Call llvm_shutdown() on exit.

	// If we have a native target, initialize it to ensure it is linked in and
	// usable by the JIT.
	InitializeNativeTarget();

	cl::ParseCommandLineOptions(argc, argv, "llvm .bc -> .bc modular optimizer and analysis printer\n");

	if (DisableDbgMsg.getValue()) {
		disable_debug_msg = true;
	} else {
		disable_debug_msg = false;
	}

	sys::PrintStackTraceOnErrorSignal();

	TRACE_1("Loading and running bitcode file\n");
	// load_bc_and_run_sc_main(argc, argv, environ);
	load_and_run_sc_main(InputFilename);

	TRACE_1("Shutdown...\n");
	return 0;
}
